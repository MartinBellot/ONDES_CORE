<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Ondes Planet</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; background: #0A0A0A; overflow: hidden; touch-action: none; }
    #c { display: block; width: 100%; height: 100%; }

    /* Hint overlay */
    #hint {
      position: fixed; bottom: 90px; left: 50%; transform: translateX(-50%);
      display: flex; flex-direction: column; align-items: center; gap: 6px;
      pointer-events: none; opacity: 0.5; transition: opacity 1s;
    }
    #hint.hidden { opacity: 0; }
    #hint-icon { width: 20px; height: 20px; fill: rgba(255,255,255,0.5); }
    #hint-text {
      font-family: 'Inter', 'Helvetica Neue', Arial, sans-serif;
      font-size: 10px; font-weight: 600; letter-spacing: 2px;
      color: rgba(255,255,255,0.6); text-transform: uppercase;
      white-space: nowrap;
    }

    /* Reset orbit button */
    #reset-btn {
      position: fixed; top: 64px; right: 20px;
      width: 40px; height: 40px; border-radius: 50%;
      background: rgba(255,255,255,0.95); border: none; cursor: pointer;
      display: flex; align-items: center; justify-content: center;
      box-shadow: 0 2px 12px rgba(0,0,0,0.4); z-index: 100;
      -webkit-tap-highlight-color: transparent;
    }
    #reset-btn:active { transform: scale(0.92); }
    #reset-btn svg { width: 20px; height: 20px; }

    /* Empty state */
    #empty-state {
      position: fixed; inset: 0; display: none;
      flex-direction: column; align-items: center; justify-content: center;
      gap: 16px; pointer-events: none;
    }
    #empty-state.visible { display: flex; }
    #empty-state svg { width: 64px; height: 64px; }
    .empty-title {
      font-family: 'Inter', 'Helvetica Neue', Arial, sans-serif;
      font-size: 18px; font-weight: 600; color: rgba(255,255,255,0.3); text-align: center;
    }
    .empty-sub {
      font-family: 'Inter', 'Helvetica Neue', Arial, sans-serif;
      font-size: 14px; color: rgba(255,255,255,0.18); text-align: center;
    }

    /* Focus ring */
    .focus-label {
      position: fixed; background: rgba(28,28,30,0.9);
      backdrop-filter: blur(8px); border-radius: 20px;
      padding: 4px 10px; pointer-events: none; z-index: 50;
      font-family: 'Inter', 'Helvetica Neue', Arial, sans-serif;
      font-size: 12px; color: #EBEBF5; display: none;
      border: 0.5px solid rgba(255,255,255,0.15);
      white-space: nowrap;
    }
    #focus-ring {
      position: fixed; border: 2px solid #007AFF; border-radius: 50%;
      pointer-events: none; z-index: 49; display: none;
      box-shadow: 0 0 12px rgba(0,122,255,0.5);
    }

    /* intro: pure camera zoom — no CSS overlay */
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <!-- Hint overlay -->
  <div id="hint">
    <svg id="hint-icon" viewBox="0 0 24 24">
      <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 14.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zm1-4.5h-2V7h2v5z"/>
    </svg>
    <span id="hint-text">Explorer l'univers</span>
  </div>

  <!-- Reset orbit FAB -->
  <button id="reset-btn" onclick="resetOrbit()">
    <svg viewBox="0 0 24 24" fill="none" stroke="#0A0A0A" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="3"/>
      <path d="M6.05 6.05a7 7 0 1 0 9.9 0M12 1v3M12 20v3"/>
    </svg>
  </button>

  <!-- Empty state -->
  <div id="empty-state">
    <svg viewBox="0 0 24 24" fill="none">
      <circle cx="12" cy="12" r="10" stroke="rgba(175,82,222,0.5)" stroke-width="1.5"/>
      <circle cx="12" cy="12" r="6"  stroke="rgba(0,122,255,0.4)"  stroke-width="1.5" stroke-dasharray="3 3"/>
      <circle cx="12" cy="12" r="2"  fill="rgba(90,200,250,0.6)"/>
    </svg>
    <span class="empty-title">Votre univers est vide</span>
    <span class="empty-sub">Installez des apps depuis le Store</span>
  </div>

  <!-- Focus label (follows selected pin) -->
  <div class="focus-label" id="focus-label"></div>
  <div id="focus-ring"></div>

  <!-- Three.js from CDN (r160 stable) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

  <script>
'use strict';

// ══════════════════════════════════════════════════════════════
// BRIDGE  Flutter <-> JS
// ══════════════════════════════════════════════════════════════
var _flutterReady = false;

window.addEventListener('flutterInAppWebViewPlatformReady', function() {
  _flutterReady = true;
  _callFlutter('onReady', {});
});

function _callFlutter(name, data) {
  try {
    if (_flutterReady && window.flutter_inappwebview) {
      window.flutter_inappwebview.callHandler(name, data);
    }
  } catch(e) { /* silent */ }
}

// Entry point called by Flutter after passing apps data
window.initGlobe = function(appsJson) {
  var apps = JSON.parse(appsJson);
  _clearPins();
  _buildPins(apps);
  if (apps.length === 0) {
    document.getElementById('empty-state').classList.add('visible');
  } else {
    document.getElementById('empty-state').classList.remove('visible');
    setTimeout(function() {
      document.getElementById('hint').classList.add('hidden');
    }, 4000);
  }
};

window.refreshApps = function(appsJson) {
  window.initGlobe(appsJson);
};

// ══════════════════════════════════════════════════════════════
// SHADERS GLSL
// ══════════════════════════════════════════════════════════════
var VERT_BASE = [
  'varying vec3 vNormal;',
  'varying vec3 vPosition;',
  'varying vec2 vUv;',
  'void main() {',
  '  vNormal = normalize(normalMatrix * normal);',
  '  vPosition = (modelMatrix * vec4(position, 1.0)).xyz;',
  '  vUv = uv;',
  '  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);',
  '}'
].join('\n');



var ATMOS_FRAG = [
  'uniform float uTime;',
  'uniform vec3 uCamPos;',
  'varying vec3 vNormal;',
  'varying vec3 vPosition;',
  'void main() {',
  '  vec3 viewDir = normalize(uCamPos - vPosition);',
  '  float fr = pow(max(1. - dot(normalize(vNormal), viewDir), 0.), 2.5);',
  '  float pulse = 0.5 + 0.12 * sin(uTime * 0.9);',
  '  gl_FragColor = vec4(0.0, 0.478, 1.0, fr * 0.32 * pulse);',
  '}'
].join('\n');

// ── Icon disc shader — animated glow rim matching brand palette ──
var DISC_VERT = [
  'varying vec2 vUv;',
  'void main() {',
  '  vUv = uv;',
  '  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);',
  '}'
].join('\n');

var DISC_FRAG = [
  'uniform sampler2D uIcon;',
  'uniform float uTime;',
  'uniform float uHover;',
  'varying vec2 vUv;',
  'void main() {',
  '  vec4 icon = texture2D(uIcon, vUv);',
  '  float dist = length(vUv - vec2(0.5)) * 2.0;',
  '  float rim  = smoothstep(0.68, 1.0, dist);',
  '  float t    = sin(uTime * 1.4) * 0.5 + 0.5;',
  '  vec3 cA = vec3(0.0, 0.478, 1.0);',
  '  vec3 cB = vec3(0.686, 0.322, 0.871);',
  '  float hoverBoost = 1.0 + uHover * 0.9;',
  '  vec3 glow = mix(cA, cB, t) * hoverBoost;',
  '  vec3 col  = icon.rgb + glow * rim * (0.65 + 0.45 * sin(uTime * 1.1));',
  '  float alpha = icon.a * smoothstep(1.02, 0.84, dist);',
  '  gl_FragColor = vec4(col, alpha);',
  '}'
].join('\n');

// ══════════════════════════════════════════════════════════════
// SCENE SETUP
// ══════════════════════════════════════════════════════════════
var canvas = document.getElementById('c');
var renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: false });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x0A0A0A, 1);

var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera(58, window.innerWidth / window.innerHeight, 0.01, 100);
camera.position.z = 3.2;

// ── Lights — warm golden-hour palette ──
scene.add(new THREE.AmbientLight(0x1A0D04, 0.55));  // warm charcoal ambient for night side

// Hemisphere light: warm sky above, ruddy ground below
var hemiLight = new THREE.HemisphereLight(0x6688CC, 0x7B4C1E, 0.38);
scene.add(hemiLight);

// ── Sun pivot: orbits independently of globe rotation ──
var sunPivot = new THREE.Group();
scene.add(sunPivot);

var SUN_DIST = 16;

// Sun core — large, vivid golden-orange
var sunMesh = new THREE.Mesh(
  new THREE.SphereGeometry(0.80, 24, 24),
  new THREE.MeshBasicMaterial({ color: 0xFFCC33 })
);
sunMesh.position.set(SUN_DIST, 0, 0);
sunPivot.add(sunMesh);

// Inner corona — warm white
var sunInnerHalo = new THREE.Mesh(
  new THREE.SphereGeometry(1.20, 18, 18),
  new THREE.MeshBasicMaterial({
    color: 0xFFEE99, transparent: true, opacity: 0.28,
    blending: THREE.AdditiveBlending, depthWrite: false
  })
);
sunInnerHalo.position.copy(sunMesh.position);
sunPivot.add(sunInnerHalo);

// Mid orange halo
var sunMidHalo = new THREE.Mesh(
  new THREE.SphereGeometry(1.90, 16, 16),
  new THREE.MeshBasicMaterial({
    color: 0xFF7700, transparent: true, opacity: 0.11,
    blending: THREE.AdditiveBlending, depthWrite: false
  })
);
sunMidHalo.position.copy(sunMesh.position);
sunPivot.add(sunMidHalo);

// Outer far corona (large soft glow)
var sunOuterHalo = new THREE.Mesh(
  new THREE.SphereGeometry(3.2, 12, 12),
  new THREE.MeshBasicMaterial({
    color: 0xFF5500, transparent: true, opacity: 0.032,
    blending: THREE.AdditiveBlending, depthWrite: false
  })
);
sunOuterHalo.position.copy(sunMesh.position);
sunPivot.add(sunOuterHalo);

// Sun directional light — warm golden — intensity higher for drama
var sunLight = new THREE.DirectionalLight(0xFFBB66, 3.4);
sunLight.position.set(SUN_DIST, 0, 0);
sunLight.target.position.set(0, 0, 0);
sunPivot.add(sunLight);
sunPivot.add(sunLight.target);

// Soft night-side fill (deep navy bounce)
var fillLight = new THREE.DirectionalLight(0x182844, 0.18);
fillLight.position.set(-10, -3, -8);
scene.add(fillLight);

// Warm accent point light used by _animateOpen
var coreLight = new THREE.PointLight(0xFFAA44, 0.55, 6);
scene.add(coreLight);

// ── Globe group (everything that rotates together) ──
var globeGroup = new THREE.Group();
scene.add(globeGroup);

// ── Planet sphere — low-poly faceted grass (Le Petit Prince) ──
var _rawPlanetGeo = new THREE.IcosahedronGeometry(1, 3);
var planetGeo = _rawPlanetGeo.toNonIndexed();
planetGeo.computeVertexNormals();

var GRASS_PALETTE = [
  new THREE.Color(0x3CB843), new THREE.Color(0x44CC4A),
  new THREE.Color(0x29A032), new THREE.Color(0x52D45A),
  new THREE.Color(0x228B22), new THREE.Color(0x35B53C),
  new THREE.Color(0x68E070), new THREE.Color(0x1E9E26)
];
var _pCount = planetGeo.attributes.position.count;
var _vColors = new Float32Array(_pCount * 3);
for (var _fi = 0; _fi < _pCount; _fi += 3) {
  var _gc = GRASS_PALETTE[Math.floor(Math.random() * GRASS_PALETTE.length)];
  for (var _vi = 0; _vi < 3; _vi++) {
    _vColors[(_fi + _vi) * 3]     = _gc.r;
    _vColors[(_fi + _vi) * 3 + 1] = _gc.g;
    _vColors[(_fi + _vi) * 3 + 2] = _gc.b;
  }
}
planetGeo.setAttribute('color', new THREE.BufferAttribute(_vColors, 3));

var planetMat = new THREE.MeshLambertMaterial({ vertexColors: true, flatShading: true });
var planetMesh = new THREE.Mesh(planetGeo, planetMat);
globeGroup.add(planetMesh);

// ── Atmosphere ──
var atmosGeo = new THREE.SphereGeometry(1.1, 48, 48);
var atmosMat = new THREE.ShaderMaterial({
  uniforms: {
    uTime:   { value: 0 },
    uCamPos: { value: camera.position }
  },
  vertexShader: VERT_BASE,
  fragmentShader: ATMOS_FRAG,
  transparent: true,
  side: THREE.FrontSide,
  blending: THREE.AdditiveBlending,
  depthWrite: false
});
globeGroup.add(new THREE.Mesh(atmosGeo, atmosMat));

// ── Pins group (child of globeGroup so it rotates with the planet) ──
var pinGroup = new THREE.Group();
globeGroup.add(pinGroup);

// ── Star field ── (must be declared after globeGroup)
_buildStars();

// ── Grass (Le Petit Prince style) ──
_buildGrass();

// ══════════════════════════════════════════════════════════════
// STARS
// ══════════════════════════════════════════════════════════════
function _buildStars() {
  var COUNT = 1600;
  var pos = new Float32Array(COUNT * 3);
  var R = 22;
  for (var i = 0; i < COUNT; i++) {
    var phi   = Math.acos(2 * Math.random() - 1);
    var theta = Math.random() * Math.PI * 2;
    pos[i*3]   = R * Math.sin(phi) * Math.cos(theta);
    pos[i*3+1] = R * Math.cos(phi);
    pos[i*3+2] = R * Math.sin(phi) * Math.sin(theta);
  }
  var geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));

  // Circular star sprite via CanvasTexture
  var sc = document.createElement('canvas');
  sc.width = sc.height = 32;
  var sctx = sc.getContext('2d');
  var sg = sctx.createRadialGradient(16,16,0, 16,16,14);
  sg.addColorStop(0,   'rgba(255,255,255,1)');
  sg.addColorStop(0.25,'rgba(200,220,255,0.9)');
  sg.addColorStop(1,   'rgba(255,255,255,0)');
  sctx.fillStyle = sg;
  sctx.fillRect(0,0,32,32);
  var starTex = new THREE.CanvasTexture(sc);

  var mat = new THREE.PointsMaterial({
    map: starTex,
    size: 0.18,
    sizeAttenuation: true,
    transparent: true,
    opacity: 0.88,
    alphaTest: 0.01,
    blending: THREE.AdditiveBlending,
    depthWrite: false
  });
  globeGroup.add(new THREE.Points(geo, mat));
}

// ══════════════════════════════════════════════════════════════
// GRASS + FLOWERS — richly realistic, Le Petit Prince spirit
// ══════════════════════════════════════════════════════════════
function _buildGrass() {
  var TUFT_COUNT   = 160;
  var FLOWER_COUNT = 32;
  var grassGroup   = new THREE.Group();
  var _up = new THREE.Vector3(0, 1, 0);

  // Base → tip gradient for blades
  var BLADE_BASE = [0x1F7A28, 0x2A9B30, 0x228B22, 0x1A7C1A, 0x257830];
  var BLADE_TIP  = [0x7AEB82, 0x68E070, 0x88F070, 0x5ADA62, 0x90EE78];

  // Flower palette
  var FLOWER_COLORS = [
    { petal: 0xFFFFFF, center: 0xFFDD00 }, // daisy
    { petal: 0xFFBBDD, center: 0xFFCC00 }, // pink rose
    { petal: 0xCC88FF, center: 0xFFBB00 }, // lavender
    { petal: 0xFFEE88, center: 0xFF7700 }, // sunflower-ish
    { petal: 0xFF9999, center: 0xFFFF66 }  // soft red poppy
  ];

  // ─── Grass tufts (curved multi-segment blades) ───
  for (var t = 0; t < TUFT_COUNT; t++) {
    var phi   = Math.acos(2 * Math.random() - 1);
    var theta = Math.random() * Math.PI * 2;
    var nx = Math.sin(phi) * Math.cos(theta);
    var ny = Math.cos(phi);
    var nz = Math.sin(phi) * Math.sin(theta);
    var normal = new THREE.Vector3(nx, ny, nz).normalize();

    var pivot = new THREE.Object3D();
    pivot.position.copy(normal);
    pivot.quaternion.setFromUnitVectors(_up, normal);

    var bladesInTuft = 3 + Math.floor(Math.random() * 5); // 3-7 blades
    for (var b = 0; b < bladesInTuft; b++) {
      var totalH = 0.060 + Math.random() * 0.055;
      var baseW  = 0.011 + Math.random() * 0.007;
      var curve  = (Math.random() - 0.4) * 0.55; // random bend direction

      var baseCol = new THREE.Color(BLADE_BASE[Math.floor(Math.random() * BLADE_BASE.length)]);
      var tipCol  = new THREE.Color(BLADE_TIP [Math.floor(Math.random() * BLADE_TIP.length)]);

      // Root pivot fans blades around Y
      var bladeRoot = new THREE.Object3D();
      bladeRoot.rotateY((b / bladesInTuft) * Math.PI * 2 + (Math.random() - 0.5) * 0.5);
      bladeRoot.rotateX((Math.random() - 0.5) * 0.45);
      pivot.add(bladeRoot);

      // 4 stacked segments → curved blade
      var SEG = 4;
      var accY = 0;
      for (var s = 0; s < SEG; s++) {
        var tf    = s / (SEG - 1);
        var segH  = totalH / SEG;
        var segW  = baseW * (1.0 - tf * 0.75);
        var col   = new THREE.Color().lerpColors(baseCol, tipCol, tf);
        // Tapered quad
        var shape = new THREE.Shape();
        shape.moveTo(-segW * 0.5, 0);
        shape.lineTo( segW * 0.5, 0);
        shape.lineTo( segW * (tf < 0.9 ? 0.1 : 0.0), segH);
        shape.lineTo(-segW * (tf < 0.9 ? 0.1 : 0.0), segH);
        shape.closePath();

        var geo  = new THREE.ShapeGeometry(shape);
        var mat  = new THREE.MeshLambertMaterial({ color: col, side: THREE.DoubleSide });
        var mesh = new THREE.Mesh(geo, mat);

        var segPivot = new THREE.Object3D();
        segPivot.position.y = accY;
        segPivot.rotation.z = curve * tf;  // progressive bend
        segPivot.add(mesh);
        bladeRoot.add(segPivot);
        accY += segH;
      }
    }
    grassGroup.add(pivot);
  }

  // ─── Flowers ───
  for (var f = 0; f < FLOWER_COUNT; f++) {
    var phi2   = Math.acos(2 * Math.random() - 1);
    var theta2 = Math.random() * Math.PI * 2;
    var fn2x = Math.sin(phi2) * Math.cos(theta2);
    var fn2y = Math.cos(phi2);
    var fn2z = Math.sin(phi2) * Math.sin(theta2);
    var fNormal = new THREE.Vector3(fn2x, fn2y, fn2z).normalize();

    var fPivot = new THREE.Object3D();
    fPivot.position.copy(fNormal);
    fPivot.quaternion.setFromUnitVectors(_up, fNormal);
    // Random tilt for variety
    fPivot.rotateX((Math.random() - 0.5) * 0.3);
    fPivot.rotateZ((Math.random() - 0.5) * 0.3);

    var fc     = FLOWER_COLORS[Math.floor(Math.random() * FLOWER_COLORS.length)];
    var stemH  = 0.048 + Math.random() * 0.038;

    // Stem (slightly curved via Object3D offset)
    var sGeo = new THREE.CylinderGeometry(0.0016, 0.0024, stemH, 5);
    var sMat = new THREE.MeshLambertMaterial({ color: 0x2A9B30 });
    var stem = new THREE.Mesh(sGeo, sMat);
    stem.position.y = stemH * 0.5;
    fPivot.add(stem);

    // Receptacle (small green bump under petals)
    var recGeo = new THREE.SphereGeometry(0.005, 6, 4);
    var recMat = new THREE.MeshLambertMaterial({ color: 0x2D9C32 });
    var rec = new THREE.Mesh(recGeo, recMat);
    rec.position.y = stemH;
    fPivot.add(rec);

    // Center disc
    var cGeo = new THREE.SphereGeometry(0.0075, 8, 6);
    var cMat = new THREE.MeshLambertMaterial({ color: fc.center });
    var center = new THREE.Mesh(cGeo, cMat);
    center.position.y = stemH + 0.004;
    fPivot.add(center);

    // Petals (oval disc, looked-at origin so they splay outward)
    var nPetals = 5 + Math.floor(Math.random() * 3);
    for (var p = 0; p < nPetals; p++) {
      var pAngle = (p / nPetals) * Math.PI * 2 + Math.random() * 0.2;
      var pr = 0.014 + Math.random() * 0.004; // reach
      // Flatten a sphere into an oval petal
      var pGeo = new THREE.SphereGeometry(0.011, 7, 4);
      var pMat = new THREE.MeshLambertMaterial({ color: fc.petal, side: THREE.DoubleSide });
      var petal = new THREE.Mesh(pGeo, pMat);
      petal.scale.set(0.45, 0.22, 0.95);
      petal.position.set(
        Math.cos(pAngle) * pr,
        stemH + 0.003,
        Math.sin(pAngle) * pr
      );
      // Tilt each petal outward slightly
      petal.rotation.z = -pAngle + Math.PI * 0.5;
      fPivot.add(petal);
    }
    grassGroup.add(fPivot);
  }

  globeGroup.add(grassGroup);
}

// ══════════════════════════════════════════════════════════════
// PINS SYSTEM
// ══════════════════════════════════════════════════════════════
var _apps = [];
var _pinGroups = []; // THREE.Group per app
var _hitMeshes = []; // for raycaster
var _focusedId = null;

// Fibonacci uniform distribution on sphere surface
function _fibSphere(i, total) {
  if (total === 1) return new THREE.Vector3(0, 1, 0);
  var phi = Math.acos(1 - (2 * (i + 0.5) / total));
  var theta = Math.PI * (3 - Math.sqrt(5)) * i; // golden angle
  return new THREE.Vector3(
    Math.sin(phi) * Math.cos(theta),
    Math.cos(phi),
    Math.sin(phi) * Math.sin(theta)
  );
}

// Create icon CanvasTexture
function _iconTexture(app, cb) {
  var sz = 128;
  var c2 = document.createElement('canvas');
  c2.width = sz; c2.height = sz;
  var ctx = c2.getContext('2d');

  function drawBase() {
    ctx.clearRect(0, 0, sz, sz);
    ctx.fillStyle = '#1C1C1E';
    ctx.beginPath(); ctx.arc(sz/2, sz/2, sz/2 - 2, 0, Math.PI*2); ctx.fill();
  }
  function drawBorder(hex) {
    ctx.strokeStyle = hex || 'rgba(255,255,255,0.18)';
    ctx.lineWidth = hex ? 3.5 : 2;
    ctx.beginPath(); ctx.arc(sz/2, sz/2, sz/2 - 3, 0, Math.PI*2); ctx.stroke();
  }
  function drawGloss() {
    var g = ctx.createLinearGradient(0, 0, 0, sz * 0.45);
    g.addColorStop(0, 'rgba(255,255,255,0.28)');
    g.addColorStop(1, 'rgba(255,255,255,0.0)');
    ctx.fillStyle = g;
    ctx.save();
    ctx.beginPath(); ctx.arc(sz/2, sz/2, sz/2 - 2, 0, Math.PI*2); ctx.clip();
    ctx.fillRect(0, 0, sz, sz * 0.48);
    ctx.restore();
  }
  function fallback() {
    drawBase();
    ctx.font = 'bold ' + Math.round(sz * 0.38) + 'px Inter, Helvetica, Arial, sans-serif';
    ctx.fillStyle = '#FFFFFF'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText((app.name || '?')[0].toUpperCase(), sz/2, sz/2 + 2);
    drawGloss(); drawBorder();
    cb(new THREE.CanvasTexture(c2));
  }

  var src = app.iconBase64 || (app.iconUrl && app.iconUrl.startsWith('http') ? app.iconUrl : null);
  if (src) {
    var img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = function() {
      drawBase();
      ctx.save();
      ctx.beginPath(); ctx.arc(sz/2, sz/2, sz/2 - 2, 0, Math.PI*2); ctx.clip();
      ctx.drawImage(img, 2, 2, sz - 4, sz - 4);
      ctx.restore();
      drawGloss(); drawBorder();
      cb(new THREE.CanvasTexture(c2));
    };
    img.onerror = fallback;
    img.src = src;
  } else {
    fallback();
  }
}

// Create label CanvasTexture
function _labelTexture(name) {
  var w = 256, h = 44;
  var c2 = document.createElement('canvas');
  c2.width = w; c2.height = h;
  var ctx = c2.getContext('2d');
  // Pill BG
  ctx.fillStyle = 'rgba(28,28,30,0.88)';
  var r = 14;
  ctx.beginPath();
  ctx.moveTo(r, 0); ctx.lineTo(w-r, 0); ctx.arcTo(w,0,w,r,r);
  ctx.lineTo(w,h-r); ctx.arcTo(w,h,w-r,h,r);
  ctx.lineTo(r,h); ctx.arcTo(0,h,0,h-r,r);
  ctx.lineTo(0,r); ctx.arcTo(0,0,r,0,r);
  ctx.closePath(); ctx.fill();
  ctx.strokeStyle = 'rgba(255,255,255,0.1)'; ctx.lineWidth = 1; ctx.stroke();
  // Text
  ctx.font = '500 14px Inter, Helvetica, Arial, sans-serif';
  ctx.fillStyle = '#EBEBF5'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  var display = name;
  while (ctx.measureText(display).width > 220 && display.length > 3) {
    display = display.slice(0, -4) + '…';
  }
  ctx.fillText(display, w/2, h/2);
  return new THREE.CanvasTexture(c2);
}

function _buildPins(apps) {
  _apps = apps;
  var total = apps.length;
  apps.forEach(function(app, i) {
    var normal = _fibSphere(i, total); // unit vector = surface normal
    var surfPos = normal.clone().multiplyScalar(1.0);
    var pinPos  = normal.clone().multiplyScalar(1.22);

    _iconTexture(app, function(iconTex) {
      var group = new THREE.Group();
      group.userData = { appId: app.id, appIndex: i, isPin: true };

      // ── Stem cylinder ──
      var stemGeo = new THREE.CylinderGeometry(0.004, 0.004, 0.18, 8);
      var stemMat = new THREE.MeshBasicMaterial({ color: 0x007AFF, transparent: true, opacity: 0.7 });
      var stemMesh = new THREE.Mesh(stemGeo, stemMat);
      // Orient stem along the normal direction
      var up = new THREE.Vector3(0, 1, 0);
      stemMesh.quaternion.setFromUnitVectors(up, normal.clone().normalize());
      stemMesh.position.copy(surfPos.clone().add(normal.clone().multiplyScalar(0.09)));
      group.add(stemMesh);

      // ── Icon disc (raycaster target) — with animated brand glow ──
      var discGeo = new THREE.CircleGeometry(0.1, 32);
      var discMat = new THREE.ShaderMaterial({
        uniforms: {
          uIcon:  { value: iconTex },
          uTime:  { value: 0 },
          uHover: { value: 0 }
        },
        vertexShader: DISC_VERT,
        fragmentShader: DISC_FRAG,
        transparent: true,
        side: THREE.DoubleSide,
        depthTest: true
      });
      var discMesh = new THREE.Mesh(discGeo, discMat);
      discMesh.position.copy(pinPos);
      discMesh.userData = { appId: app.id, appIndex: i };
      group.add(discMesh);

      // Store refs for animations
      group._stem      = stemMesh;
      group._stemMat   = stemMat;
      group._disc      = discMesh;
      group._discMat   = discMat;
      group._normal    = normal.clone();
      group._iconTex   = iconTex;

      pinGroup.add(group);
      _pinGroups.push(group);
      _hitMeshes.push(discMesh);
    });
  });
}

function _clearPins() {
  _hitMeshes = [];
  _pinGroups = [];
  _focusedId = null;
  while (pinGroup.children.length > 0) {
    var ch = pinGroup.children[0];
    pinGroup.remove(ch);
  }
}

function _getPinGroup(appId) {
  for (var k = 0; k < _pinGroups.length; k++) {
    if (_pinGroups[k].userData.appId === appId) return _pinGroups[k];
  }
  return null;
}

// ══════════════════════════════════════════════════════════════
// FOCUS / UNFOCUS
// ══════════════════════════════════════════════════════════════
function _focusPin(appId) {
  _unfocusAll();
  _focusedId = appId;
  var g = _getPinGroup(appId);
  if (!g) return;
  g._disc.scale.setScalar(1.35);
  if (g._discMat.uniforms) g._discMat.uniforms.uHover.value = 1.0;
  g._stemMat.color.setHex(0x5AC8FA);
  g._stemMat.opacity = 1;
  // Border glow via a ring mesh
  if (!g._ring) {
    var ringGeo = new THREE.RingGeometry(0.105, 0.128, 32);
    var ringMat = new THREE.MeshBasicMaterial({ color: 0x007AFF, side: THREE.DoubleSide, transparent: true, opacity: 0.9 });
    var ringMesh = new THREE.Mesh(ringGeo, ringMat);
    ringMesh.position.copy(g._disc.position.clone().add(g._normal.clone().multiplyScalar(0.001)));
    g._ring = ringMesh;
    g._ringMat = ringMat;
    group_addRing(g);
  }
  g._ring.visible = true;
  // Zoom camera toward the selected pin
  _zoomToPin(appId);
}

// Show Flutter HUD panel for a pin (long-press / right-click only)
function _openPinPanel(appId) {
  var appData = null;
  for (var _fi2 = 0; _fi2 < _apps.length; _fi2++) {
    if (_apps[_fi2].id === appId) { appData = _apps[_fi2]; break; }
  }
  _callFlutter('onAppFocus', {
    appId: appId,
    name: appData ? (appData.name || '') : ''
  });
}

function group_addRing(g) {
  g.add(g._ring);
}

function _unfocusAll() {
  var hadFocus = (_focusedId !== null);
  _pinGroups.forEach(function(g) {
    g._disc.scale.setScalar(1.0);
    if (g._discMat.uniforms) g._discMat.uniforms.uHover.value = 0.0;
    g._stemMat.color.setHex(0x007AFF);
    g._stemMat.opacity = 0.7;
    if (g._ring) g._ring.visible = false;
  });
  _focusedId = null;
  // Notify Flutter to hide its HUD panel
  if (hadFocus) {
    _callFlutter('onAppClose', {});
    // Smoothly zoom back to default distance
    var zBack = _targetZoom;
    var t0b = performance.now();
    var durB = 700;
    (function stepBack(now) {
      var p = Math.min((now - t0b) / durB, 1);
      var e = 1 - Math.pow(1 - p, 3);
      _targetZoom = zBack + (3.2 - zBack) * e;
      if (p < 1) requestAnimationFrame(stepBack);
    })(performance.now());
  }
}

// Rotate globe + zoom so the pin faces the camera
function _zoomToPin(appId) {
  var g = _getPinGroup(appId);
  if (!g) return;

  var normal = g._normal.clone().normalize();
  // Quaternion that rotates the normal to point toward +Z (camera direction)
  var targetQuat = new THREE.Quaternion().setFromUnitVectors(
    normal, new THREE.Vector3(0, 0, 1)
  );
  var targetEuler = new THREE.Euler().setFromQuaternion(targetQuat, 'YXZ');

  var rx0 = globeGroup.rotation.x, ry0 = globeGroup.rotation.y;
  var rxT = targetEuler.x,         ryT = targetEuler.y;
  var z0 = _targetZoom,            zT  = 2.1;
  var t0 = performance.now();
  var dur = 900;
  _velX = 0; _velY = 0;
  _isTransitioning = true;

  (function step(now) {
    var p = Math.min((now - t0) / dur, 1);
    var e = 1 - Math.pow(1 - p, 3);
    globeGroup.rotation.x = rx0 + (rxT - rx0) * e;
    globeGroup.rotation.y = ry0 + (ryT - ry0) * e;
    _targetZoom = z0 + (zT - z0) * e;
    if (p < 1) { requestAnimationFrame(step); return; }
    _isTransitioning = false;
  })(performance.now());
}

// ══════════════════════════════════════════════════════════════
// CONTROLS — inertia physics
// ══════════════════════════════════════════════════════════════
var _isDragging    = false;
var _isDown        = false;
var _lastX = 0, _lastY = 0;
var _downX = 0, _downY = 0;
var _velX = 0, _velY = 0;
var FRICTION = 0.91;
var ROT_SPEED = 0.006;
var DRAG_THRESH = 8;
var _zoom = 3.2, _targetZoom = 3.2;
var _pinchDist = 0;
var _longTimer = null;
var LONG_MS = 520;
var _skipNextMouseUp = false; // set after contextmenu so mouseup doesn’t dismiss

// ── Touch ──
canvas.addEventListener('touchstart', function(e) {
  e.preventDefault();
  if (e.touches.length === 1) {
    var t = e.touches[0];
    _isDown = true; _isDragging = false;
    _lastX = t.clientX; _lastY = t.clientY;
    _downX = t.clientX; _downY = t.clientY;
    _velX = 0; _velY = 0;
    _longTimer = setTimeout(function() {
      _longTimer = null;
      var ud = _hitAt(t.clientX, t.clientY);
      if (ud) {
        _callFlutter('onHaptic', { type: 'medium' });
        _focusPin(ud.appId);
        _openPinPanel(ud.appId); // long-press → show Flutter HUD panel
      }
    }, LONG_MS);
  } else if (e.touches.length === 2) {
    _clearLong();
    var dx = e.touches[0].clientX - e.touches[1].clientX;
    var dy = e.touches[0].clientY - e.touches[1].clientY;
    _pinchDist = Math.sqrt(dx*dx + dy*dy);
  }
}, { passive: false });

canvas.addEventListener('touchmove', function(e) {
  e.preventDefault();
  if (e.touches.length === 1 && _isDown) {
    var t = e.touches[0];
    var dx = t.clientX - _lastX, dy = t.clientY - _lastY;
    var dist = Math.sqrt(Math.pow(t.clientX - _downX, 2) + Math.pow(t.clientY - _downY, 2));
    if (dist > DRAG_THRESH) { _isDragging = true; _clearLong(); }
    if (_isDragging) {
      _velX = dx * ROT_SPEED; _velY = dy * ROT_SPEED;
      globeGroup.rotation.y += _velX;
      globeGroup.rotation.x = Math.max(-1.5, Math.min(1.5, globeGroup.rotation.x + _velY));
    }
    _lastX = t.clientX; _lastY = t.clientY;
  } else if (e.touches.length === 2) {
    var dx = e.touches[0].clientX - e.touches[1].clientX;
    var dy = e.touches[0].clientY - e.touches[1].clientY;
    var d = Math.sqrt(dx*dx + dy*dy);
    _targetZoom = Math.max(1.9, Math.min(5.2, _targetZoom + (_pinchDist - d) * 0.004));
    _pinchDist = d;
  }
}, { passive: false });

canvas.addEventListener('touchend', function(e) {
  e.preventDefault();
  _clearLong();
  if (!_isDragging && e.changedTouches.length > 0) {
    var t = e.changedTouches[0];
    _handleTap(t.clientX, t.clientY);
  }
  _isDown = false;
}, { passive: false });

// ── Mouse (desktop) ──
canvas.addEventListener('mousedown', function(e) {
  _isDown = true; _isDragging = false;
  _lastX = e.clientX; _lastY = e.clientY;
  _downX = e.clientX; _downY = e.clientY;
  _velX = 0; _velY = 0;
});
canvas.addEventListener('mousemove', function(e) {
  if (!_isDown) return;
  var dx = e.clientX - _lastX, dy = e.clientY - _lastY;
  var dist = Math.sqrt(Math.pow(e.clientX - _downX, 2) + Math.pow(e.clientY - _downY, 2));
  if (dist > DRAG_THRESH) _isDragging = true;
  if (_isDragging) {
    _velX = dx * ROT_SPEED; _velY = dy * ROT_SPEED;
    globeGroup.rotation.y += _velX;
    globeGroup.rotation.x = Math.max(-1.5, Math.min(1.5, globeGroup.rotation.x + _velY));
  }
  _lastX = e.clientX; _lastY = e.clientY;
});
canvas.addEventListener('mouseup', function(e) {
  if (_skipNextMouseUp) { _skipNextMouseUp = false; _isDown = false; return; }
  if (!_isDragging) _handleTap(e.clientX, e.clientY);
  _isDown = false;
});
// Right-click → show Flutter HUD panel
canvas.addEventListener('contextmenu', function(e) {
  e.preventDefault();
  _skipNextMouseUp = true; // prevent the paired mouseup from dismissing focus
  var ud = _hitAt(e.clientX, e.clientY);
  if (ud) {
    _focusPin(ud.appId);
    _openPinPanel(ud.appId);
    _callFlutter('onHaptic', { type: 'medium' });
  }
});
canvas.addEventListener('wheel', function(e) {
  e.preventDefault();
  _targetZoom = Math.max(1.9, Math.min(5.2, _targetZoom + e.deltaY * 0.005));
}, { passive: false });

function _clearLong() {
  if (_longTimer) { clearTimeout(_longTimer); _longTimer = null; }
}

// ══════════════════════════════════════════════════════════════
// RAYCASTER
// ══════════════════════════════════════════════════════════════
var _raycaster = new THREE.Raycaster();

function _ndc(cx, cy) {
  return new THREE.Vector2(
    (cx / window.innerWidth) * 2 - 1,
    -(cy / window.innerHeight) * 2 + 1
  );
}

function _hitAt(cx, cy) {
  if (_hitMeshes.length === 0) return null;
  _raycaster.setFromCamera(_ndc(cx, cy), camera);
  var hits = _raycaster.intersectObjects(_hitMeshes, false);
  return hits.length > 0 ? hits[0].object.userData : null;
}

// ══════════════════════════════════════════════════════════════
// TAP HANDLING
// ══════════════════════════════════════════════════════════════
function _handleTap(cx, cy) {
  var ud = _hitAt(cx, cy);
  if (ud) {
    _callFlutter('onHaptic', { type: 'light' });
    if (_focusedId === ud.appId) {
      // Second left-click on already-focused pin → open app
      _callFlutter('onAppTap', { appId: ud.appId, action: 'open' });
      _animateOpen(ud.appId);
    } else {
      // First click: visual focus + zoom in (no panel — use long-press / right-click for panel)
      _focusPin(ud.appId);
    }
  } else if (_focusedId) {
    _unfocusAll(); // tap outside → unfocus + Flutter closes panel
  }
}

// ══════════════════════════════════════════════════════════════
// ANIMATIONS
// ══════════════════════════════════════════════════════════════
var _isTransitioning = false;

function _animateOpen(appId) {
  _isTransitioning = true;
  var startScale = globeGroup.scale.x;
  var t0 = performance.now();
  var dur = 650;

  // Wave ring from pin
  var g = _getPinGroup(appId);
  if (g) _spawnWaveRing(g._disc.position.clone());

  function step(now) {
    var p = Math.min((now - t0) / dur, 1);
    var e = 1 - Math.pow(1 - p, 3); // ease-out-cubic
    globeGroup.scale.setScalar(startScale * (1 - e * 0.3));
    sunLight.intensity = 2.6 + e * 2.0;
    if (p < 1) { requestAnimationFrame(step); return; }
    setTimeout(function() {
      globeGroup.scale.setScalar(1);
      sunLight.intensity = 2.6;
      _isTransitioning = false;
    }, 350);
  }
  requestAnimationFrame(step);
}

// Expanding ring effect on pin tap
var _waveRings = [];
function _spawnWaveRing(localPos) {
  var ringGeo = new THREE.RingGeometry(0.01, 0.04, 32);
  var ringMat = new THREE.MeshBasicMaterial({ color: 0x007AFF, side: THREE.DoubleSide, transparent: true, opacity: 0.9 });
  var ring = new THREE.Mesh(ringGeo, ringMat);
  ring.position.copy(localPos);
  ring.lookAt(new THREE.Vector3(0,0,0));
  pinGroup.add(ring);
  _waveRings.push({ mesh: ring, mat: ringMat, born: performance.now() });
}

function _updateWaveRings() {
  var now = performance.now();
  _waveRings = _waveRings.filter(function(w) {
    var age = (now - w.born) / 600;
    if (age >= 1) { pinGroup.remove(w.mesh); return false; }
    var e = age;
    w.mesh.scale.setScalar(1 + e * 8);
    w.mat.opacity = 0.9 * (1 - e);
    return true;
  });
}

// Reset orbit to front view
window.resetOrbit = function() {
  var rx0 = globeGroup.rotation.x, ry0 = globeGroup.rotation.y;
  var z0 = _targetZoom;
  var t0 = performance.now();
  var dur = 750;
  _velX = 0; _velY = 0;
  function step(now) {
    var p = Math.min((now - t0) / dur, 1);
    var e = 1 - Math.pow(1 - p, 3);
    globeGroup.rotation.x = rx0 * (1 - e);
    globeGroup.rotation.y = ry0 * (1 - e);
    _targetZoom = z0 + (3.2 - z0) * e;
    if (p < 1) requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
  _callFlutter('onHaptic', { type: 'light' });
};

// ══════════════════════════════════════════════════════════════
// INTRO: FLY FROM SPACE
// ══════════════════════════════════════════════════════════════
var _introPlaying = true;
var _introStart   = -1; // set when first frame arrives
var INTRO_DUR     = 2600; // ms — duration of camera dive
var INTRO_ZOOM_START = 26;
var INTRO_ZOOM_END   = 3.2;

// Start planet tiny so it appears to grow toward us
camera.position.z = INTRO_ZOOM_START;
globeGroup.scale.setScalar(0.005);

function _updateIntro(now) {
  if (!_introPlaying) return;
  if (_introStart < 0) _introStart = now;
  var p = Math.min((now - _introStart) / INTRO_DUR, 1);
  // dual-ease: rapid initial dive, then settle gently into orbit
  var e = p < 0.6
    ? 0.5 * Math.pow(p / 0.6, 1.6)             // first 60% — swift fall
    : 0.5 + 0.5 * (1 - Math.pow(1 - (p - 0.6) / 0.4, 3)); // last 40% — ease-out-cubic settle
  camera.position.z = INTRO_ZOOM_START + (INTRO_ZOOM_END - INTRO_ZOOM_START) * e;
  _zoom        = camera.position.z;
  _targetZoom  = INTRO_ZOOM_END;
  globeGroup.scale.setScalar(0.005 + 0.995 * e);
  // Slow gentle rotation during dive for drama
  globeGroup.rotation.y = (1 - e) * 1.8;
  if (p >= 1) {
    _introPlaying = false;
    camera.position.z = INTRO_ZOOM_END;
    globeGroup.scale.setScalar(1.0);
  }
}

// ══════════════════════════════════════════════════════════════
// RENDER LOOP
// ══════════════════════════════════════════════════════════════
var _lastT = 0;
function _animate(t) {
  requestAnimationFrame(_animate);
  var dt = (t - _lastT) / 1000;
  _lastT = t;

  // Intro fly-in (runs for first ~2.6 s)
  _updateIntro(t);

  var sec = t * 0.001;

  // Shader uniforms (atmosphere only — planet is MeshLambertMaterial)
  atmosMat.uniforms.uTime.value = sec;
  atmosMat.uniforms.uCamPos.value.copy(camera.position);

  // Sun orbit — oscillates in front hemisphere only (never behind planet)
  // y swings ±73° so the directional light is always visible to the camera
  sunPivot.rotation.y = Math.sin(sec * 0.055) * 1.28;
  sunPivot.rotation.z = Math.sin(sec * 0.019) * 0.44;

  // Inertia — blocked during intro or manual drag/transition
  if (!_isDown && !_isTransitioning && !_introPlaying) {
    globeGroup.rotation.y += _velX;
    globeGroup.rotation.x = Math.max(-1.5, Math.min(1.5, globeGroup.rotation.x + _velY));
    _velX *= FRICTION;
    _velY *= FRICTION;
  }

  // Zoom lerp (skipped during intro — _updateIntro controls camera.z directly)
  if (!_introPlaying) {
    _zoom += (_targetZoom - _zoom) * 0.09;
    camera.position.z = _zoom;
  }

  // Billboard: disc + ring face camera; update disc shader time
  var camWorld = new THREE.Vector3();
  camera.getWorldPosition(camWorld);
  _pinGroups.forEach(function(pg) {
    if (pg._disc) pg._disc.lookAt(camWorld);
    if (pg._ring) pg._ring.lookAt(camWorld);
    if (pg._discMat && pg._discMat.uniforms && pg._discMat.uniforms.uTime) {
      pg._discMat.uniforms.uTime.value = sec;
    }
  });

  // Wave rings
  _updateWaveRings();

  renderer.render(scene, camera);
}
requestAnimationFrame(_animate);

// ── Resize ──
window.addEventListener('resize', function() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// ── Bootstrap: if Flutter bridge is already ready when this script runs ──
setTimeout(function() {
  if (_flutterReady) _callFlutter('onReady', {});
}, 50);
  </script>
</body>
</html>
